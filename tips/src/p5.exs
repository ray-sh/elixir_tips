"""
Accumulators is a variable which keep some value from current function call and
pass to next function call

The key is: The value is generated by funciton and feed to function again.

If we have an accumulator, we could create a enumerable. Then this will bring you to
enum and stream world.


def Stream.unfold(next_acc, next_fun)

@spec unfold(acc(), (acc() -> {element(), acc()} | nil)) :: Enumerable.t()

Emits a sequence of values for the given accumulator.

Successive values are generated by calling next_fun with the previous
accumulator and it must return a tuple with the current value and next
accumulator. The enumeration finishes if it returns nil.

"""

ExUnit.start()

defmodule Test do
  use ExUnit.Case, async: true

  test "A cycle accumelator" do
    stream =
      Stream.unfold(5, fn
        0 -> {5, 4}
        n -> {n, n - 1}
      end)

    Enum.take(stream, 10)
    |> IO.inspect()
  end
end
